# 第一章 各就各位，预备！

Haskell 中的负数需要用 `()`：

```Haskell
5 * 2 * (-10)
```

## 函数调用

`*` 即为函数，但它是中缀的，称之为 **中缀函数**（infix function）。

大多数函数为 **前缀函数**：

```Haskell
succ 8
min 10 12
max 10 102
```

Haskell 中 **函数调用** 优先级最高：

```Haskell
succ 9 + max 5 4 + 1
```

等价于：

```Haskell
(succ 9) + (max 5 4) + 1
```

结果为 16。

而：

```Haskell
succ 9 * 10
```

等价于：

```Haskell
(succ 9) * 10
```

若某函数有两个参数，可以用反引号 ` 将其包裹，以中缀形式调用：

```Haskell
div 100 4
```

等价于：

```Haskell
100 `div` 4
```

## 函数定义

一个参数：

```Haskell
doubleMe x = x + x
```

* `+` 函数可用于整数、浮点数

两个参数：

```Haskell
doubleUs x y = x * 2 + y * 2
```

>Haskell 中函数定义没有 **顺序** 的概念，谁先谁后没有影响。

`doubleUs` 可以基于 `doubleMe` 定义：

```Haskell
doubleUs x y = doubleMe x + doubleMe y
```

if-then-else：

```Haskell
doubleSmallNumber x = if x > 100
                      then x
                      else x * 2
```

* `else` 不可省略

Haskell 中的 if-then-else 是表达式，而非语句：

```Haskell
doubleSmallNumber' x = (if x > 100 then x else x * 2) + 1
```

`'` 是合法的函数名字字符：

```Haskell
song'kun = "it's me Song Kun"
```

* 函数只能以 **小写** 字母开头
* 没有参数的函数，也叫定义 or 名字

## 列表入门

```Haskell
lostNumbers = [1, 2, 3, 4]
```

* 元素类型相同

### 列表拼接

```Haskell
[1, 2, 3] ++ [4, 5, 6]
"Hello" ++ "world"
['h', 'e', 'l', 'l', 'o'] ++ ['w', 'o', 'r', 'l', 'd']
```

>Haskell 字符串实际是 `[Char]` 的语法糖。

`++` 会遍历左边的列表，因此列表较长时，需要注意效率。

头部插入：

```Haskell
'A' : "Hello"
1 : [2, 3]
```

* 成本几乎为 0

注意：

```Haskell
[1, 2, 3]
```

是

```Haskell
1 : 2 : 3 []
```

的语法糖。

### 访问列表元素

按索引：

```Haskell
[1, 2, 3] !! 2
```

* 索引从 0 开始
* 小心越界错误

### 嵌套列表

```Haskell
[[1, 2, 3], [4, 5, 6]]
```

嵌套的列表长度可以不同，但类型必须相同。

### 比较列表

只要 **列表元素** 可以比较大小，就可用 `>`、`<`、`>=` 等比较列表大小，规则如下：

* 比较两个列表第一个元素，若相等，比较第二个 ...
* 直到遇到不相等的元素，列表大小以该元素比较为准

```Haskell
[1, 2, 3] < [2]
```

>非空列表总是比 `[]` 大。

### 更多列表操作

`head`：

```Haskell
head [1, 2, 3]  -- 1
```

`tail`：

```Haskell
tail [1, 2, 3]  -- [2, 3]
```

`last`：

```Haskell
last [1, 2, 3]  -- 3
```

`init`：

```Haskell
init [1, 2, 3]  -- [1, 2]
```

这 4 个函数用于 `[]` 都会报错，且编译时无法发现。

`null` 检查列表是否为空：

```Haskell
null [1, 2, 3]  -- False
null []  -- True
```

`reverse` 翻转列表：

```Haskell
reverse [1, 2, 3]  -- [3, 2, 1]
```

`take`：

```Haskell
take 3 [1, 2, 3, 4]  -- [1, 2, 3]
```

若 `n` 超过列表长度，会获取整个列表：

```Haskell
take 100 [1, 2, 3, 4]  -- [1, 2, 3, 4]
```

`drop` 与 `take` 相反：

```Haskell
drop 3 [1, 2, 3, 4] -- [4]
drop 0 [1, 2, 3, 4] -- [1, 2, 3, 4]
drop 100 [1, 2, 3, 4]  -- []
```

最大、最小元素（元素必须可比较）：

```Haskell
maximum [1, 2, 3, 4]  -- 4
minimum [1, 2, 3, 4]  -- 1
```

所有元素之和、之积：

```Haskell
sum [1, 2, 3, 4]  -- 10
product [1, 2, 3, 4]  -- 24
```

是否包含某元素：

```Haskell
1 `elem` [1, 2, 3]  -- True
```

* 常用中缀形式调用

## 区间

区间（range）是构造列表的方式之一，区间中的元素必须是可排序的:

```Haskell
[1 .. 20]
['a' ..  'z']
```

获取 1-20 之间所有偶数：

```Haskell
-- [2,4,6,8,10,12,14,16,18,20]
[2, 4 .. 20]
```

* 列出前两个元素 `[2, 4]`，加上区间上界 `20` 即可
* 通过列出前两个元素，可以指定 **步长**

1-20 间 3 的倍数：

```Haskell
[3, 6 .. 20]
-- [3,6,9,12,15,18]
```

20-1 的区间不能用 `[20 .. 1]`，而必须用：

```Haskell
[20, 19 .. 1]
```

**注意**，因为浮点数不精确，所以用于区间会导致很蛋疼的问题，尽量不用：

```Haskell
[0.1, 0.3 .. 1]  
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

不指定区间 **上界** 将得到无限区间：

```Haskell
[1, 2 ..]
```

利用无限列表，可以做一些很漂亮的计算，比如 1 * 14 到 14 * 13：

```Haskell
take 14 [13, 26 ..]
```

### 产生无限列表的函数

`cycle` 接受一个 list 作为参数，并将参数重复无数次：

```Haskell
take 10 (cycle [1, 2, 3])
```

`repeat` 接受一个元素，并将该元素重复无数次：

```Haskell
take 10 (repeat 99)
```

* 等价于 `cycle [99]`

`replicate` 可以指定重复次数：

```Haskell
replicate 3 99  -- [99, 99, 99]
```

## list 推导

获取前 10 个偶数：

```Haskell
[x * 2 | x <- [1 .. 10]]
-- [2,4,6,8,10,12,14,16,18,20]
```

加断言，获取前 10 个偶数中，大于等于 12 的集合：

```Haskell
[x * 2 | x <- [1 .. 10], x * 2 >= 12]
-- [12,14,16,18,20]
```

获取 50-100 之间，被 7 取模为 3 的整数列表：

```Haskell
[x | x <- [50..100], x `mod` 7 == 3]
-- [52,59,66,73,80,87,94]
```

将列表 `xs` 中所有大于 10 的奇数变成 `BANG`，小于 10 的奇数变成 `BOOM`，其余扔掉：

```Haskell
boomBang xs = [if x > 10 then "BANG" else "BOOM" | x <- xs, odd x]
```

>`odd x` 是谓词，过滤作用。

可以有多个谓词，用 `,` 分割：

```Haskell
[x | x <- [10..20], x /= 7, x /= 13]
```

可以同时推导 **多个列表**：

```Haskell
[(x, y) | x <- [1, 2, 3], y <- ['a', 'b']]
-- [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
```

* `x` 和 `y` 的所有组合
* `x` 取 1，然后 `y` 取 `[a, b]` 中的所有值 ...

再如：

```Haskell
[x * y | x <- [2, 5, 10], y <- [8, 10, 11], x * y > 50]
-- [55,80,100,110]
```

通过列表推导实现 `length'`：

```Haskell
length' :: [a] -> Int
length' xs = sum [1 | _ <- xs]
```

字符串是 `[Char]` 列表，可使用列表推导：

```Haskell
removeNoUppercase :: String -> String
removeNoUppercase s = [x | x <- s, x `elem` ['A' .. 'Z']]

removeNoUppercase "Hello, World!"  -- "HW"
```

嵌套推导，去除嵌套列表中的奇数：

```Haskell
removeOdd :: [[Int]] -> [[Int]]
removeOdd xss = [[x | x <- xs, even x] | xs <- xss]

removeOdd [[1, 2, 3], [4, 5], [6]]  -- [[2],[4],[6]]
```

## 元组

元组类似列表，但：

* 元组的元素类型可以不同
* 元组的 **长度** 固定

```Haskell
(1, 2)
(2, 'a', "Hello")
```

### 使用 tuple

二维向量可以用列表表示：`[1, 2]`，那二维向量的列表呢就是 `[[1, 2], [3, 4], [20, -1]]`，这没问题，但 `[[1, 2, 3], [2, 3]]` 从类型看是合法的向量列表，但其中 `[1, 2, 3]` 却并非合法向量。

可以用元组表示二维向量：`(1, 2)`，向量列表为：`[(1, 2), (2, 3)]`，如果添加 `(1, 2, 3)` 将报错，因为 `(1, 2)` 与 `(1, 2, 3)` 类型不同，而列表要求元素类型必须相同。

**注意**：元组最少有两个元素，不存在只有一个元素的元组，因为只有一个元素的元组与单个元素性质相同，没有必要重复。

### 使用 pair

含两个元素的 tuple 称为 pair。

`fst` 和 `snd` 分别返回 pair 的第一、二个元素：

```Haskell
fst' :: (a, b) -> a
fst' (x, _) = x

snd' :: (a, b) -> b
snd' (_, y) = y
```

`zip` 函数生成 `[(a, b)]`：

```Haskell
zip [1, 2, 3] ['a', 'b', 'c', 'd']
-- [(1,'a'),(2,'b'),(3,'c')]

zip [1 ..] ['a'..'z']
-- [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10,'j'),(11,'k'),(12,'l'),(13,'m'),(14,'n'),(15,'o'),(16,'p'),(17,'q'),(18,'r'),(19,'s'),(20,'t'),(21,'u'),(22,'v'),(23,'w'),(24,'x'),(25,'y'),(26,'z')]
```

* 较长的列表将被截断
* `zip` 可用 `[1..]` 无限列表生成索引

### 找出直角三角形

结合 list 推导和 tuple 找出满足以下条件的直角三角形：

* 三边长度均为整数
* 三边长度均小于等于 10
* 周长等于 24

```Haskell
[(a, b, c) | c <- [1..10], b <- [1..c], a <- [1..b], a ^ 2 + b ^ 2 == c ^ 2, a + b + c == 24]
-- [(6,8,10)]
```

* c 为斜边，注意 a, b, c 的范围
